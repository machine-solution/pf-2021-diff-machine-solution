----------------------------SUCCESS------------------------------------------------------------------------------------
@ a 1 @
> using System.Collections.Generic;
@ d 19-20 @
> /// <summary> Бот для режима без телепортов </summary>
> public class Bot_v1: Bot {
@ a 20-24 @
> /// <summary> Бот: version 1.5 </summary>
> public class Bot_Bob: Bot {
>     /// <summary> Бот: version 1.5 </summary>
>     public Bot_Bob() {}
>     //constants
@ a 26-28 @
> 
>     //variables
>     //NOT RELOAD
@ d 26-38 @
>         try {
>             Players = the_players;
>             Treasures = the_treasures;
>             Size = the_size;
>             my_id = the_id;
>             players = new player[Players];
>             for (int i = 0; i < Players; ++i) {
>                 players[i].A = new Map(2 * Size); players[i].B = new Map(2 * Size);
>                 players[i].id = i;
>             }
>             my_map = new Map(2 * Size);
>             hosp_map = new Map(2 * Size);
>             UpdateStats();
@ a 30-177 @
>     protected int treasures, treasuresOut, knifes, bullets, armors, crackers;
>     //RELOAD
>     protected int k, choice;
>     protected bool aftHosp;
>     public Map hosp_map, my_map;
>     public player[] players;
>     //  BFS
>     protected int[] v = new int[2];
>     protected int[][] notExpl = new int[11][];
>     protected int[,][] p;
>     protected int[][] path;
>     protected bool[,] used;
>     protected int path_size, notExpl_size;
> 
>     //structures and classes
>     public struct player {
>         public Map A, B;
>         public int treasures, treasuresOut, knifes, bullets, armors, crackers, id;
>         public bool spy;
>         public int dspy_x, dspy_y;
>         public int choice;
>         public bool aftHosp;
>         public void UpdateStats() {
>             treasures = Check.treasures(id);
>             treasuresOut = Check.treasureOut(id);
>             armors = Check.armors(id);
>             knifes = Check.knifes(id);
>             bullets = Check.bullets(id);
>             crackers = Check.crackers(id);
>         }
>         public int X() => B.x + dspy_x;
>         public int Y() => B.y + dspy_y;
>     }
>     public class Map {
>         public int size;
>         public int rank;
>         public int x, y;
>         public int minx, miny, maxx, maxy;
>         public int[] exit;
>         public int[,,] can_to_move;
>         void Init(int Size) {
>             size = Size;
>             rank = 0;
>             minx = maxx = miny = maxy = x = y = size / 2 - 1;
>             can_to_move = new int[size, size, 2];
>             exit = new int[3] { -1, -1, -1 };
>         }
>         public Map(int Size) => Init(Size);
>         public Map copy() => new Map(this);
>         Map(Map B) {
>             Init(B.size);
>             B.UpdateBorders();
>             rank = B.rank;
>             minx = B.minx; miny = B.miny;
>             maxx = B.maxx; maxy = B.maxy;
>             x = B.x; y = B.y;
>             exit = new int[3] { B.exit[0], B.exit[1], B.exit[2] };
>             for (int i = 0; i < size; ++i)
>                 for (int j = 0; j < size; ++j) {
>                     can_to_move[i, j, 0] = B.can_to_move[i, j, 0];
>                     can_to_move[i, j, 1] = B.can_to_move[i, j, 1];
>                 }
>         }
>         public void Move(int side) {
>             if (side == LEFT) { if (x == minx) --minx; --x; }
>             if (side == DOWN) { if (y == miny) --miny; --y; }
>             if (side == RIGHT) { if (x == maxx) ++maxx; ++x; }
>             if (side == UP) { if (y == maxy) ++maxy; ++y; }
>         }
>         public int Can(int a, int b, int side) {
>             int dx = (side == RIGHT ? 1 : 0), dy = (side == UP ? 1 : 0);
>             return can_to_move[a + dx, b + dy, side % 2];
>         }
>         public void UpdateCoord(int a, int b) {
>             x = a; y = b;
>         }
>         public void UpdateCan(int res, int side) {
>             int dx = (side == RIGHT ? 1 : 0), dy = (side == UP ? 1 : 0);
>             can_to_move[x + dx, y + dy, side % 2] = res;
>             rank += res > 0 ? res : -res;
>         }
>         public void UpdateCan(int a, int b, int res, int side) {
>             int dx = (side == RIGHT ? 1 : 0), dy = (side == UP ? 1 : 0);
>             can_to_move[a + dx, b + dy, side % 2] = res;
>             rank += res > 0 ? res : -res;
>         }
>         public void UpdateExit(int side) {
>             exit = new int[3] { x, y, side }; UpdateBorders();
>         }
>         public void UpdateExit(int a, int b, int side) {
>             exit = new int[3] { a, b, side }; UpdateBorders();
>         }
>         public void AddWall(int a, int b, int side) {
>             if (can_to_move[a, b, side] == UNKNOWN) UpdateCan(a, b, WALL, side);
>         }
>         public void AddFree(int a, int b, int side) {
>             if (can_to_move[a, b, side] == UNKNOWN) UpdateCan(a, b, FREE, side);
>         }
>         public void UpdateBorders() {
>             if (exit[0] > -1) {
>                 int a = exit[0], b = exit[1], side = exit[2], Size = size / 2;
>                 bool A = (side == LEFT && (a < 0 || a >= 2 * Size || a + Size < 0 || a + Size >= 2 * Size));
>                 bool B = (side == DOWN && (b < 0 || b >= 2 * Size || b + Size < 0 || b + Size >= 2 * Size));
>                 bool C = (side == RIGHT && (a + 1 < 0 || a + 1 >= 2 * Size || a + 1 - Size < 0 || a + 1 - Size >= 2 * Size));
>                 bool D = (side == UP && (b + 1 < 0 || b + 1 >= 2 * Size || b + 1 - Size < 0 || b + 1 - Size >= 2 * Size));
>                 if (A || B || C || D) exit[0] = -2;
>                 else {
>                     if (side == LEFT && maxy - miny == Size - 1) {
>                         for (int i = a; i < a + Size; ++i) { AddWall(i, miny, 1); AddWall(i, miny + Size, 1); }
>                         for (int j = miny; j <= maxy; ++j) { AddWall(a, j, 0); AddWall(a + Size, j, 0); }
>                     }
>                     else if (side == DOWN && maxx - minx == Size - 1) {
>                         for (int i = minx; i <= maxx; ++i) { AddWall(i, b, 1); AddWall(i, b + Size, 1); }
>                         for (int j = b; j < b + Size; ++j) { AddWall(minx, j, 0); AddWall(minx + Size, j, 0); }
>                     }
>                     else if (side == RIGHT && maxy - miny == Size - 1) {
>                         for (int i = a + 1 - Size; i < a + 1; ++i) { AddWall(i, miny, 1); AddWall(i, miny + Size, 1); }
>                         for (int j = miny; j <= maxy; ++j) { AddWall(a + 1 - Size, j, 0); AddWall(a + 1, j, 0); }
>                     }
>                     else if (side == UP && maxx - minx == Size - 1) {
>                         for (int i = minx; i <= maxx; ++i) { AddWall(i, b + 1 - Size, 1); AddWall(i, b + 1, 1); }
>                         for (int j = b + 1 - Size; j < b + 1; ++j) { AddWall(minx, j, 0); AddWall(minx + Size, j, 0); }
>                     }
>                 }
>             }
>         }
>         public void NewLife() {
>             minx = maxx = miny = maxy = x = y = size / 2 - 1;
>             can_to_move = new int[size, size, 2];
>             exit = new int[3] { -1, -1, -1 };
>             rank = 0;
>         }
>     }
> 
>     //functions
>     protected virtual void Reload() {
>         k = choice = 0;
>         aftHosp = false;
>         hosp_map = my_map = null;
>         players = null;
>         v = new int[2];
>         notExpl = new int[11][];
>         p = null;
>         path = null;
>         used = null;
>         Join(Players, Treasures, Size, my_id);
>         RandomAns();
>     }
@ d 40-43 @
>         catch (System.Exception e) {
>             broken = true;
>             error += e.Message + "\n" + e.StackTrace + "\n";
>         }
@ d 45-46 @
>     protected int k, choice;
>     protected int Stoi(string m) {
@ d 61-66 @
>     protected int[] v = new int[2];
>     protected int[][] notExpl = new int[11][];
>     protected int[,][] p;
>     protected int[][] path;
>     protected bool[,] used;
>     protected int path_size, notExpl_size;
@ d 74 @
>         System.Collections.Generic.Queue<int[]> q = new System.Collections.Generic.Queue<int[]>();
@ d 154 @
>             else if (treasures > 0 && rand.Next(t) == 0 && (my_map.exit[0] > -1 ? p[my_map.exit[0], my_map.exit[1]] != null : false)) {
@ a 181-188 @
>         Players = the_players;
>         Treasures = the_treasures;
>         Size = the_size;
>         my_id = the_id;
>         players = new player[Players];
>         for (int i = 0; i < Players; ++i) {
>             players[i].A = new Map(2 * Size); players[i].B = new Map(2 * Size);
>             players[i].id = i;
@ a 190-192 @
>         my_map = new Map(2 * Size);
>         hosp_map = new Map(2 * Size);
>         UpdateStats();
@ a 194 @
>     protected int SideToNum(string m) {
@ d 194-295 @
>     public class Map {
>         public int size;
>         public int rank;
>         public int x, y;
>         public int minx, miny, maxx, maxy;
>         public int[] exit;
>         public int[,,] can_to_move;
>         void Init(int Size) {
>             size = Size;
>             rank = 0;
>             minx = maxx = miny = maxy = x = y = size / 2 - 1;
>             can_to_move = new int[size, size, 2];
>             exit = new int[3] { -1, -1, -1 };
>         }
>         public Map(int Size) => Init(Size);
>         public Map copy() => new Map(this);
>         Map(Map B) {
>             Init(B.size);
>             B.UpdateBorders();
>             rank = B.rank;
>             minx = B.minx; miny = B.miny;
>             maxx = B.maxx; maxy = B.maxy;
>             x = B.x; y = B.y;
>             exit = new int[3] { B.exit[0], B.exit[1], B.exit[2] };
>             for (int i = 0; i < size; ++i)
>                 for (int j = 0; j < size; ++j) {
>                     can_to_move[i, j, 0] = B.can_to_move[i, j, 0];
>                     can_to_move[i, j, 1] = B.can_to_move[i, j, 1];
>                 }
>         }
>         public void Move(int side) {
>             if (side == LEFT) { if (x == minx) --minx; --x; }
>             if (side == DOWN) { if (y == miny) --miny; --y; }
>             if (side == RIGHT) { if (x == maxx) ++maxx; ++x; }
>             if (side == UP) { if (y == maxy) ++maxy; ++y; }
>         }
>         public int Can(int a, int b, int side) {
>             int dx = (side == RIGHT ? 1 : 0), dy = (side == UP ? 1 : 0);
>             return can_to_move[a + dx, b + dy, side % 2];
>         }
>         public void UpdateCoord(int a, int b) {
>             x = a; y = b;
>         }
>         public void UpdateCan(int res, int side) {
>             int dx = (side == RIGHT ? 1 : 0), dy = (side == UP ? 1 : 0);
>             can_to_move[x + dx, y + dy, side % 2] = res;
>             rank += res > 0 ? res : -res;
>         }
>         public void UpdateCan(int a, int b, int res, int side) {
>             int dx = (side == RIGHT ? 1 : 0), dy = (side == UP ? 1 : 0);
>             can_to_move[a + dx, b + dy, side % 2] = res;
>             rank += res > 0 ? res : -res;
>         }
>         public void UpdateExit(int side) {
>             exit = new int[3] { x, y, side }; UpdateBorders();
>         }
>         public void UpdateExit(int a, int b, int side) {
>             exit = new int[3] { a, b, side }; UpdateBorders();
>         }
>         public void AddWall(int a, int b, int side) {
>             if (can_to_move[a, b, side] == UNKNOWN) UpdateCan(a, b, WALL, side);
>         }
>         public void AddFree(int a, int b, int side) {
>             if (can_to_move[a, b, side] == UNKNOWN) UpdateCan(a, b, FREE, side);
>         }
>         public void UpdateBorders() {
>             if (exit[0] > -1) {
>                 int a = exit[0], b = exit[1], side = exit[2], Size = size / 2;
>                 bool A = (side == LEFT && (a < 0 || a >= 2 * Size || a + Size < 0 || a + Size >= 2 * Size));
>                 bool B = (side == DOWN && (b < 0 || b >= 2 * Size || b + Size < 0 || b + Size >= 2 * Size));
>                 bool C = (side == RIGHT && (a + 1 < 0 || a + 1 >= 2 * Size || a + 1 - Size < 0 || a + 1 - Size >= 2 * Size));
>                 bool D = (side == UP && (b + 1 < 0 || b + 1 >= 2 * Size || b + 1 - Size < 0 || b + 1 - Size >= 2 * Size));
>                 if (A || B || C || D) exit[0] = -2;
>                 else {
>                     if (side == LEFT && maxy - miny == Size - 1) {
>                         for (int i = a; i < a + Size; ++i) { AddWall(i, miny, 1); AddWall(i, miny + Size, 1); }
>                         for (int j = miny; j <= maxy; ++j) { AddWall(a, j, 0); AddWall(a + Size, j, 0); }
>                     }
>                     else if (side == DOWN && maxx - minx == Size - 1) {
>                         for (int i = minx; i <= maxx; ++i) { AddWall(i, b, 1); AddWall(i, b + Size, 1); }
>                         for (int j = b; j < b + Size; ++j) { AddWall(minx, j, 0); AddWall(minx + Size, j, 0); }
>                     }
>                     else if (side == RIGHT && maxy - miny == Size - 1) {
>                         for (int i = a + 1 - Size; i < a + 1; ++i) { AddWall(i, miny, 1); AddWall(i, miny + Size, 1); }
>                         for (int j = miny; j <= maxy; ++j) { AddWall(a + 1 - Size, j, 0); AddWall(a + 1, j, 0); }
>                     }
>                     else if (side == UP && maxx - minx == Size - 1) {
>                         for (int i = minx; i <= maxx; ++i) { AddWall(i, b + 1 - Size, 1); AddWall(i, b + 1, 1); }
>                         for (int j = b + 1 - Size; j < b + 1; ++j) { AddWall(minx, j, 0); AddWall(minx + Size, j, 0); }
>                     }
>                 }
>             }
>         }
>         public void NewLife() {
>             minx = maxx = miny = maxy = x = y = size / 2 - 1;
>             can_to_move = new int[size, size, 2];
>             exit = new int[3] { -1, -1, -1 };
>             rank = 0;
>         }
>     }
>     public Map hosp_map, my_map;
>     protected bool aftHosp;
@ a 216 @
>         Queue<int[]> q = new Queue<int[]>();
@ a 296 @
>             else if (treasures > 0 && rand.Next(t) == 0 && (my_map.exit[0] > -1 && p[my_map.exit[0], my_map.exit[1]] != null)) {
@ d 297-298 @
>         if (A.rank >= B.rank) return A.copy();
>         else return B.copy();
@ a 337 @
>         return A.rank >= B.rank ? A.copy() : B.copy();
@ d 372 @
>                         
@ a 411 @
> 
@ d 418-419 @
>         if (var == 0 || A.exit[0] == -2) { GetInfoB(); return my_map; }
>         else return A;
@ d 453-471 @
>     public struct player {
>         public Map A, B;
>         public int treasures, treasuresOut, knifes, bullets, armors, crackers, id;
>         public bool spy;
>         public int dspy_x, dspy_y;
>         public int choice;
>         public bool aftHosp;
>         public void UpdateStats() {
>             treasures = Check.treasures(id);
>             treasuresOut = Check.treasureOut(id);
>             armors = Check.armors(id);
>             knifes = Check.knifes(id);
>             bullets = Check.bullets(id);
>             crackers = Check.crackers(id);
>         }
>         public int X() => B.x + dspy_x;
>         public int Y() => B.y + dspy_y;
>     }
>     public player[] players;
@ a 457 @
>         if (var == 0 || A.exit[0] == -2) { GetInfoB(); return my_map; } else return A;
@ d 519-545 @
>         if (!broken) {
>             try {
>                 int game = GameAns(gameAns_id); k = Stoi(ansSide_id);
>                 if (gameAns_id == "hit\n") {
>                     if (id != my_id) {
>                         bool A = Check.treasures(my_id) == 0 && (players[my_id].B.Can(players[my_id].B.x, players[my_id].B.y, (k + 2) % 4) > -1 || players[id].choice == 4);
>                         if (ansType_id != "throw") {
>                             if (armors == 0 && A) {
>                                 if (treasures > 0) {
>                                     players[my_id].A = High(players[my_id].A, players[my_id].B);
>                                     used = new bool[2 * Size, 2 * Size]; //init
>                                     void DFS(int a, int b) {
>                                         used[a, b] = true;
>                                         if (a < hosp_map.minx) hosp_map.minx = a; if (a > hosp_map.maxx) hosp_map.maxx = a;
>                                         if (b < hosp_map.miny) hosp_map.miny = b; if (b > hosp_map.maxy) hosp_map.maxy = b;
>                                         if (hosp_map.Can(a, b, 0) == 1) if (!used[a - 1, b]) DFS(a - 1, b);
>                                         if (hosp_map.Can(a, b, 1) == 1) if (!used[a, b - 1]) DFS(a, b - 1);
>                                         if (hosp_map.Can(a, b, 2) == 1) if (!used[a + 1, b]) DFS(a + 1, b);
>                                         if (hosp_map.Can(a, b, 3) == 1) if (!used[a, b + 1]) DFS(a, b + 1);
>                                     }
>                                     DFS(hosp_map.minx, hosp_map.miny);
>                                     hosp_map = Merge(hosp_map, players[my_id].A);
>                                     hosp_map.UpdateCoord(Size - 1, Size - 1);
>                                     players[my_id].B = hosp_map.copy();
>                                     GetInfoB();
>                                     UpdateAns();
>                                     aftHosp = true;
@ a 538-555 @
>         try {
>             int game = GameAns(gameAns_id); k = SideToNum(ansSide_id);
>             if (gameAns_id == "hit\n") {
>                 if (id != my_id) {
>                     bool A = Check.treasures(my_id) == 0 && (players[my_id].B.Can(players[my_id].B.x, players[my_id].B.y, (k + 2) % 4) > -1 || players[id].choice == 4);
>                     if (ansType_id != "throw") {
>                         if (armors == 0 && A) {
>                             if (treasures > 0) {
>                                 players[my_id].A = High(players[my_id].A, players[my_id].B);
>                                 used = new bool[2 * Size, 2 * Size]; //init
>                                 void DFS(int a, int b) {
>                                     used[a, b] = true;
>                                     if (a < hosp_map.minx) hosp_map.minx = a; if (a > hosp_map.maxx) hosp_map.maxx = a;
>                                     if (b < hosp_map.miny) hosp_map.miny = b; if (b > hosp_map.maxy) hosp_map.maxy = b;
>                                     if (hosp_map.Can(a, b, 0) == 1) if (!used[a - 1, b]) DFS(a - 1, b);
>                                     if (hosp_map.Can(a, b, 1) == 1) if (!used[a, b - 1]) DFS(a, b - 1);
>                                     if (hosp_map.Can(a, b, 2) == 1) if (!used[a + 1, b]) DFS(a + 1, b);
>                                     if (hosp_map.Can(a, b, 3) == 1) if (!used[a, b + 1]) DFS(a, b + 1);
@ d 547-551 @
>                                 else {
>                                     aftHosp = false;
>                                     players[my_id].A = High(players[my_id].A, players[my_id].B);
>                                     players[my_id].B.NewLife();
>                                 }
@ d 553-563 @
>                             if (armors != Check.armors(my_id) && ansType_id == "strike" && players[id].choice != 4) {
>                                 int dx = 0, dy = 0;
>                                 if (k == 0) dx = 1; if (k == 2) dx = -1;
>                                 if (k == 1) dy = 1; if (k == 3) dy = -1;
>                                 Add(players[my_id].B, players[id].B, dx, dy);
>                                 if (players[my_id].B.Can(players[my_id].B.x, players[my_id].B.y, (k + 2) % 4) == 0) {
>                                     players[my_id].B.UpdateCan(1, (k + 2) % 4);
>                                 }
>                                 Add(my_map, players[my_id].B, 0, 0);
>                                 if (ConflictMove()) GetInfoB();
>                                 if (ConflictWall()) GetInfoB();
@ a 557-563 @
>                                 DFS(hosp_map.minx, hosp_map.miny);
>                                 hosp_map = Merge(hosp_map, players[my_id].A);
>                                 hosp_map.UpdateCoord(Size - 1, Size - 1);
>                                 players[my_id].B = hosp_map.copy();
>                                 GetInfoB();
>                                 UpdateAns();
>                                 aftHosp = true;
@ a 565-568 @
>                             else {
>                                 aftHosp = false;
>                                 players[my_id].A = High(players[my_id].A, players[my_id].B);
>                                 players[my_id].B.NewLife();
@ d 566-569 @
>                         else {
>                             if (A) {
>                                 choice = 4;
>                                 UpdateAns();
@ a 571-577 @
>                         if (armors != Check.armors(my_id) && ansType_id == "strike" && players[id].choice != 4) {
>                             int dx = 0, dy = 0;
>                             if (k == 0) dx = 1; if (k == 2) dx = -1;
>                             if (k == 1) dy = 1; if (k == 3) dy = -1;
>                             Add(players[my_id].B, players[id].B, dx, dy);
>                             if (players[my_id].B.Can(players[my_id].B.x, players[my_id].B.y, (k + 2) % 4) == 0) {
>                                 players[my_id].B.UpdateCan(1, (k + 2) % 4);
@ d 573-578 @
>                     for (int i = 0; i < Players; ++i)
>                         if (i != id && i != my_id) {
>                             bool A = players[i].B.Can(players[i].B.x, players[i].B.y, (k + 2) % 4) > -1 || players[id].choice == 4;
>                             if (ansType_id != "throw") {
>                                 if (Check.treasures(i) == 0 && players[i].armors == 0 && A) {
>                                     bool B = players[id].choice != 4 && (id != my_id || choice != 4);
@ a 579-581 @
>                             Add(my_map, players[my_id].B, 0, 0);
>                             if (ConflictMove()) GetInfoB();
>                             if (ConflictWall()) GetInfoB();
@ d 580-590 @
>                                     //strike and hit mean that dist(i,id)==1 
>                                     if (ansType_id == "strike" && players[i].treasures > 0 && B) {
>                                         int dx = 0, dy = 0;
>                                         if (k == 0) dx = -1; if (k == 2) dx = 1;
>                                         if (k == 1) dy = -1; if (k == 3) dy = 1;
>                                         Add(players[id].B, players[i].B, dx, dy);
>                                         if (id == my_id) {
>                                             Add(my_map, players[my_id].B, 0, 0);
>                                             if (ConflictMove()) GetInfoB();
>                                             if (ConflictWall()) GetInfoB();
>                                         }
@ a 584-596 @
>                     else {
>                         if (A) {
>                             choice = 4;
>                             UpdateAns();
>                         }
>                     }
>                 }
>                 for (int i = 0; i < Players; ++i)
>                     if (i != id && i != my_id) {
>                         bool A = players[i].B.Can(players[i].B.x, players[i].B.y, (k + 2) % 4) > -1 || players[id].choice == 4;
>                         if (ansType_id != "throw") {
>                             if (Check.treasures(i) == 0 && players[i].armors == 0 && A) {
>                                 bool B = players[id].choice != 4 && (id != my_id || choice != 4);
@ d 593-596 @
>                                     players[i].A = High(players[i].A, players[i].B);
>                                     players[i].B.NewLife();
>                                     if (players[i].treasures > 0) players[i].aftHosp = true;
>                                     else players[i].aftHosp = false;
@ d 598-599 @
>                                     Spy_off(i); //Jam
>                                 }
@ a 598-607 @
>                                 //strike and hit mean that dist(i,id)==1 
>                                 if (ansType_id == "strike" && players[i].treasures > 0 && B) {
>                                     int dx = 0, dy = 0;
>                                     if (k == 0) dx = -1; if (k == 2) dx = 1;
>                                     if (k == 1) dy = -1; if (k == 3) dy = 1;
>                                     Add(players[id].B, players[i].B, dx, dy);
>                                     if (id == my_id) {
>                                         Add(my_map, players[my_id].B, 0, 0);
>                                         if (ConflictMove()) GetInfoB();
>                                         if (ConflictWall()) GetInfoB();
@ d 601 @
>                             else if (A) players[i].choice = 4;
@ d 603-617 @
>                 }
>                 if (id == my_id) {
>                     if (ansType_id != "step") {
>                         if (choice != 4) {
>                             if (ansType_id != "throw") {
>                                 if (game == 0) { players[my_id].B.UpdateCan(WALL, k); GetInfoB(); } //lose knife
>                                 else if (game == 2 && SmbLosed()) {
>                                     if (ansType_id == "strike") choice = 2;
>                                     if (ansType_id == "fire") choice = 3;
>                                 }
>                             }
>                             else if (game == 2) choice = 4;
>                         }
>                         else if (ansType_id != "throw") {
>                             if (game == 2 && SmbLosed()) {
@ a 609 @
>                                 }
@ a 611-613 @
>                                 players[i].A = High(players[i].A, players[i].B);
>                                 players[i].B.NewLife();
>                                 players[i].aftHosp = players[i].treasures > 0;
@ a 615 @
>                                 Spy_off(i); //Jam
@ a 618-626 @
>                         else if (A) players[i].choice = 4;
>                     }
>             }
>             if (id == my_id) {
>                 if (ansType_id != "step") {
>                     if (choice != 4) {
>                         if (ansType_id != "throw") {
>                             if (game == 0) { players[my_id].B.UpdateCan(WALL, k); GetInfoB(); } //lose knife
>                             else if (game == 2 && SmbLosed()) {
@ d 621 @
>                             else choice = 0;
@ d 623-624 @
>                         else if (game != 2) choice = 0;
>                         else choice = 4;
@ d 626-630 @
>                     else UpdateCan_and_xy(game, k);
>                     my_map = Merge(my_map, players[my_id].A);
>                     players[my_id].B = Merge(players[my_id].B, players[my_id].A);
>                     players[my_id].A = Merge(players[my_id].A, players[my_id].B);
>                     UpdateAns();
@ a 631 @
>                         else if (game == 2) choice = 4;
@ a 633-641 @
>                     else if (ansType_id != "throw") {
>                         if (game == 2 && SmbLosed()) {
>                             if (ansType_id == "strike") choice = 2;
>                             if (ansType_id == "fire") choice = 3;
>                         }
>                         else choice = 0;
>                     }
>                     else if (game != 2) choice = 0;
>                     else choice = 4;
@ d 633-645 @
>                     if (gameAns_id == "hit\n") {
>                         int x = players[id].B.x, y = players[id].B.y;
>                         if (ansType_id != "throw" && players[id].choice == 4) players[id].choice = 0;
>                         if (ansType_id == "throw" && (players[id].B.Can(x, y, k) != 1 || players[id].choice == 4))
>                             players[id].choice = 4;
>                     }
>                     else {
>                         if (ansType_id == "step") {
>                             if (players[id].choice != 4) {
>                                 int res;
>                                 if (game == 0) {
>                                     res = -1;
>                                     players[id].B.UpdateCan(res, k);
@ a 643-655 @
>                 else UpdateCan_and_xy(game, k);
>                 my_map = Merge(my_map, players[my_id].A);
>                 players[my_id].B = Merge(players[my_id].B, players[my_id].A);
>                 players[my_id].A = Merge(players[my_id].A, players[my_id].B);
>                 UpdateAns();
>             }
>             else {
>                 if (gameAns_id == "hit\n") {
>                     int x = players[id].B.x, y = players[id].B.y;
>                     if (ansType_id != "throw" && players[id].choice == 4) players[id].choice = 0;
>                     if (ansType_id == "throw" && (players[id].B.Can(x, y, k) != 1 || players[id].choice == 4))
>                         players[id].choice = 4;
>                 }
@ d 647-663 @
>                                 if (game == 1) {
>                                     res = 1;
>                                     players[id].B.UpdateCan(res, k);
>                                     players[id].B.Move(k);
>                                 }
>                                 if (game == 2) {
>                                     res = -2;
>                                     players[id].B.UpdateCan(res, k);
>                                     players[id].B.UpdateExit(k);
>                                 }
>                                 if (players[id].aftHosp) {
>                                     Add(hosp_map, players[id].B, players[id].B.x - Size + 1, players[id].B.y - Size + 1);
>                                     if (IsJam()) {
>                                         Add(players[id].B, hosp_map, Size - 1 - players[id].B.x, Size - 1 - players[id].B.y);
>                                         if (!players[id].spy) Spy_on(id);
>                                     }
>                                 }
@ a 657-678 @
>                     if (ansType_id == "step") {
>                         if (players[id].choice != 4) {
>                             int res;
>                             if (game == 0) {
>                                 res = -1;
>                                 players[id].B.UpdateCan(res, k);
>                             }
>                             if (game == 1) {
>                                 res = 1;
>                                 players[id].B.UpdateCan(res, k);
>                                 players[id].B.Move(k);
>                             }
>                             if (game == 2) {
>                                 res = -2;
>                                 players[id].B.UpdateCan(res, k);
>                                 players[id].B.UpdateExit(k);
>                             }
>                             if (players[id].aftHosp) {
>                                 Add(hosp_map, players[id].B, players[id].B.x - Size + 1, players[id].B.y - Size + 1);
>                                 if (IsJam()) {
>                                     Add(players[id].B, hosp_map, Size - 1 - players[id].B.x, Size - 1 - players[id].B.y);
>                                     if (!players[id].spy) Spy_on(id);
@ d 665 @
>                             else {
@ d 667-673 @
>                                 if (game == 1) {
>                                     players[id].A = High(players[id].A, players[id].B);
>                                     players[id].B.NewLife();
>                                     players[id].choice = 0;
>                                     players[id].aftHosp = false;
>                                     Spy_off(id);
>                                 }
@ d 676-681 @
>                         else { if (players[id].choice == 4) players[id].choice = 0; }
>                         players[my_id].B = Merge(players[my_id].B, players[id].A);
>                         players[my_id].B = Merge(players[my_id].B, players[id].B);
>                         my_map = Merge(my_map, players[id].A);
>                         my_map = Merge(my_map, players[id].B);
>                         Spy_on(id);
@ a 681-686 @
>                         }
>                         else {
>                             players[id].choice = 0;
>                             if (game == 1) {
>                                 players[id].A = High(players[id].A, players[id].B);
>                                 players[id].B.NewLife();
@ d 684-686 @
>                 players[id].UpdateStats();
>                 UpdateStats();
>                 TryKill();
@ a 688-689 @
>                                 players[id].aftHosp = false;
>                                 Spy_off(id);
@ d 688-692 @
>             catch (System.Exception e) {
>                 broken = true;
>                 error += e.Message + "\n" + e.StackTrace + "\n";
>                 randomAns();
>             }
@ a 693-698 @
>                     else { if (players[id].choice == 4) players[id].choice = 0; }
>                     players[my_id].B = Merge(players[my_id].B, players[id].A);
>                     players[my_id].B = Merge(players[my_id].B, players[id].B);
>                     my_map = Merge(my_map, players[id].A);
>                     my_map = Merge(my_map, players[id].B);
>                     Spy_on(id);
@ d 694 @
>         else randomAns();
@ d 696-697 @
>     protected int treasures, treasuresOut, knifes, bullets, armors, crackers;
>     //Jam.begin();
@ a 701-703 @
>             players[id].UpdateStats();
>             UpdateStats();
>             TryKill();
@ d 703-704 @
>     //Jam.end();
>     protected void randomAns() {
@ a 705-709 @
>         catch (System.Exception e) {
>             broken = true;
>             error = e.Message + "\n" + e.StackTrace + "\n";
>             Reload();
>         }
@ a 711 @
>     //Jam
@ a 717-718 @
>     //~Jam
>     protected void RandomAns() {
@ d 719-720 @
> /// <summary> Бот для режима без телепортов: version 1.0 </summary>
> public class Bot_Alice: Bot_v1 {
@ d 726-738 @
>         try {
>             Players = the_players;
>             Treasures = the_treasures;
>             Size = the_size;
>             my_id = the_id;
>             x = y = 9;
>             players = new player[the_players];
>             knifes = 1;
>         }
>         catch (System.Exception e) {
>             broken = true;
>             error += e.Message + "\n" + e.StackTrace + "\n";
>         }
@ a 733-744 @
> /// <summary> Бот: version 1.0 </summary>
> public class Bot_Alice: Bot_Bob {
>     /// <summary> Бот: version 1.0 </summary>
>     public Bot_Alice() { }
>     //variables
>     new player[] players;
>     new int[] v = new int[2];
>     new int[][] notExpl = new int[11][];
>     new int[,][] p = new int[20, 20][];
>     new int[][] path = new int[101][];
>     new bool[,] used = new bool[20, 20];
>     new int path_size, notExpl_size;
@ a 747-773 @
>     int[] exit = { -1, -1, -1 };
>     bool doubt;
> 
>     //structures
>     new struct player {
>         public int treasures;
>     }
> 
>     //functions
>     protected override void Reload() {
>         k = choice = 0;
>         aftHosp = false;
>         hosp_map = my_map = null;
>         players = null;
>         v = new int[2];
>         notExpl = new int[11][];
>         p = new int[20, 20][];
>         path = new int[101][];
>         used = new bool[20, 20];
>         path_size = notExpl_size = 0;
>         exit = new int[] { -1, -1, -1 };
>         x = y = 0;
>         can_to_move = new int[20, 20, 2];
>         doubt = false;
>         Join(Players, Treasures, Size, my_id);
>         RandomAns();
>     }
@ d 750-755 @
>     new int[] v = new int[2];
>     new int[][] notExpl = new int[11][];
>     new int[,][] p = new int[20, 20][];
>     new int[][] path = new int[101][];
>     new bool[,] used = new bool[20, 20];
>     new int path_size, notExpl_size;
@ d 763 @
>         System.Collections.Generic.Queue<int[]> q = new System.Collections.Generic.Queue<int[]>();
@ a 777-783 @
>         Players = the_players;
>         Treasures = the_treasures;
>         Size = the_size;
>         my_id = the_id;
>         x = y = 9;
>         players = new player[the_players];
>         UpdateStats();
@ a 802 @
>         Queue<int[]> q = new Queue<int[]>();
@ d 805 @
>         if (choice == 0) UpdateChoice();
@ d 807 @
>         if (choice == 2) {
@ d 817 @
>     int[] exit = { -1, -1, -1 };
@ d 819 @
>     bool doubt;
@ d 821-833 @
>         bool A = (x == exit[0]) && (y == exit[1]) && doubt;
>         if (knifes > 0 && rand.Next(5) == 0 && Have(FREE, x, y) && !A) { ansType = "strike"; ansSide = Random(FREE); }
>         else if (bullets > 0 && rand.Next(5) == 0 && Have(FREE, x, y) && !A) { ansType = "fire"; ansSide = Random(FREE); }
>         else {
>             ansType = "step"; int t = Max((Treasures - SumOut()) / 2 - treasures, 1);
>             if ((x == exit[0] && y == exit[1] && treasures > 0) || (x == exit[0] && y == exit[1] && doubt)) { ansSide = sides[exit[2]]; }
>             else if (treasures > 0 && exit[0] > -1 && rand.Next(t) == 0) {
>                 v[0] = exit[0]; v[1] = exit[1];
>                 BFS();
>                 Path(v[0], v[1]);
>                 choice = 1;
>             }
>             else if (Have(UNKNOWN, x, y)) ansSide = Random(UNKNOWN);
@ d 835-838 @
>                 BFS();
>                 if (notExpl_size > 0) {
>                     t = rand.Next(rand.Next(notExpl_size)) + 1;
>                     v[0] = notExpl[t][0]; v[1] = notExpl[t][1];
@ d 842 @
>                 else ansSide = Random(FREE);
@ a 844 @
>         UpdateChoice();
@ a 846 @
>         else if (choice == 2) {
@ a 855 @
>         else if (choice > 2) Reload();
@ a 859-862 @
>         if (choice == 0) {
>             bool A = (x == exit[0]) && (y == exit[1]) && doubt;
>             if (knifes > 0 && rand.Next(5) == 0 && Have(FREE, x, y) && !A) { ansType = "strike"; ansSide = Random(FREE); }
>             else if (bullets > 0 && rand.Next(5) == 0 && Have(FREE, x, y) && !A) { ansType = "fire"; ansSide = Random(FREE); }
@ a 864-868 @
>                 ansType = "step"; int t = Max((Treasures - SumOut()) / 2 - treasures, 1);
>                 if ((x == exit[0] && y == exit[1] && treasures > 0) || (x == exit[0] && y == exit[1] && doubt)) { ansSide = sides[exit[2]]; }
>                 else if (treasures > 0 && exit[0] > -1 && rand.Next(t) == 0) {
>                     v[0] = exit[0]; v[1] = exit[1];
>                     BFS();
@ d 872 @
>             else newLife();
@ a 872-882 @
>                 else if (Have(UNKNOWN, x, y)) ansSide = Random(UNKNOWN);
>                 else {
>                     BFS();
>                     if (notExpl_size > 0) {
>                         t = rand.Next(rand.Next(notExpl_size)) + 1;
>                         v[0] = notExpl[t][0]; v[1] = notExpl[t][1];
>                         Path(v[0], v[1]);
>                         choice = 1;
>                     }
>                     else ansSide = Random(FREE);
>                 }
@ d 876-877 @
>                 if (x == exit[0] && y == exit[1] && game != 2) newLife();
>                 else if (game == 0) newLife();
@ d 880 @
>                 if (x == -1 || y == -1 || x == 19 || y == 19) newLife();
@ d 889-900 @
>     void newLife() {
>         x = y = 9;
>         aftHosp = false;
>         can_to_move = new int[20, 20, 2];
>         choice = 0;
>         exit[0] = exit[1] = exit[2] = -1;
>         doubt = false;
>     }
>     new struct player {
>         public int treasures;
>     }
>     new player[] players;
@ d 902-908 @
>         if (!broken) {
>             try {
>                 int game = GameAns(gameAns_id); k = Stoi(ansSide_id);
>                 if (id == my_id) {
>                     if (ansType_id != "step") { if (game == 2 && SmbLosed()) choice = 2; if (game == 0 && choice != 4) newLife(); if (choice == 4) choice = 0; }
>                     else UpdateCan_and_xy(game, k);
>                     UpdateAns();
@ d 910-919 @
>                 else {
>                     if (gameAns_id == "hit\n") {
>                         if (ansType_id == "throw") {
>                             if (knifes > 0) { ansType = "strike"; ansSide = (Have(FREE, x, y)) ? Random(FREE) : Random(UNKNOWN); }
>                             else if (bullets > 0) { ansType = "fire"; ansSide = (Have(FREE, x, y)) ? Random(FREE) : Random(UNKNOWN); }
>                             else { ansType = "step"; ansSide = (Have(WALL, x, y)) ? Random(WALL) : Random(UNKNOWN); }
>                             choice = 4;
>                         }
>                         else if (Check.treasures(my_id) == 0 && armors == 0) {
>                             if (treasures > 0 || exit[0] == -1) { newLife(); UpdateAns(); }
@ a 912 @
>             else Reload();
@ a 916-917 @
>                 if (x == exit[0] && y == exit[1] && game != 2) Reload();
>                 else if (game == 0) Reload();
@ a 920 @
>                 if (x == -1 || y == -1 || x == 19 || y == 19) Reload();
@ d 921-929 @
>                                 doubt = true;
>                                 v[0] = exit[0]; v[1] = exit[1];
>                                 if (x == v[0] && y == v[1]) choice = 0;
>                                 else {
>                                     BFS();
>                                     Path(v[0], v[1]);
>                                     choice = 1;
>                                 }
>                                 UpdateAns();
@ a 929 @
> 
@ a 931-937 @
>         try {
>             int game = GameAns(gameAns_id); k = SideToNum(ansSide_id);
>             if (id == my_id) {
>                 if (ansType_id != "step") {
>                     if (game == 2 && SmbLosed()) choice = 2;
>                     if (game == 0 && choice != 4) Reload();
>                     if (choice == 4) choice = 0;
@ d 934-935 @
>                 players[id].treasures = Check.treasures(id);
>                 UpdateStats();
@ d 937-941 @
>             catch (System.Exception e) {
>                 broken = true;
>                 randomAns();
>                 error += e.Message + "\n" + e.StackTrace + "\n";
>             }
@ a 939-953 @
>                 else UpdateCan_and_xy(game, k);
>                 UpdateAns();
>             }
>             else {
>                 if (gameAns_id == "hit\n") {
>                     if (ansType_id == "throw") {
>                         if (knifes > 0) { ansType = "strike"; ansSide = (Have(FREE, x, y)) ? Random(FREE) : Random(UNKNOWN); } else if (bullets > 0) { ansType = "fire"; ansSide = (Have(FREE, x, y)) ? Random(FREE) : Random(UNKNOWN); } else { ansType = "step"; ansSide = (Have(WALL, x, y)) ? Random(WALL) : Random(UNKNOWN); }
>                         choice = 4;
>                     }
>                     else if (Check.treasures(my_id) == 0 && armors == 0) {
>                         if (treasures > 0 || exit[0] == -1) { Reload(); UpdateAns(); }
>                         else {
>                             doubt = true;
>                             v[0] = exit[0]; v[1] = exit[1];
>                             if (x == v[0] && y == v[1]) choice = 0;
@ d 943 @
>         else randomAns();
@ d 952-957 @
> /// <summary> Бот для режима без телепортов: version 1.5 </summary>
> public class Bot_Bob: Bot_v1 {
> 
> }
> /// <summary> Бот для режима без телепортов: version 1.6 </summary>
> public class Bot_Jam: Bot_v1 {
@ a 955-957 @
>                                 BFS();
>                                 Path(v[0], v[1]);
>                                 choice = 1;
@ a 959 @
>                             UpdateAns();
@ d 960 @
>         used = new bool[2 * Size, 2 * Size]; 
@ a 964-965 @
>             players[id].treasures = Check.treasures(id);
>             UpdateStats();
@ d 965 @
>         System.Collections.Generic.Queue<int[]> q = new System.Collections.Generic.Queue<int[]>();
@ a 967-971 @
>         catch (System.Exception e) {
>             broken = true;
>             error = e.Message + "\n" + e.StackTrace + "\n";
>             Reload();
>         }
@ a 980-983 @
> /// <summary> Бот: version 1.6 </summary>
> public class Bot_Jam: Bot_Bob {
>     /// <summary> Бот: version 1.6 </summary>
>     public Bot_Jam() { }
@ a 986 @
>         used = new bool[2 * Size, 2 * Size];
@ a 991 @
>         Queue<int[]> q = new Queue<int[]>();
@ a 1111-1171 @
> /// <summary> Бот: version 2.0 (in developing) </summary>
> public class Bot_v2: Bot {
>     //protected void BFS(int[,] indspy) {
>     //    //init
>     //    used = new bool[2 * Size, 2 * Size];
>     //    p = new int[2 * Size, 2 * Size][];
>     //    notExpl = new int[11][];
>     //    notExpl_size = 0;
> 
>     //    Queue<int[]> q = new Queue<int[]>();
>     //    int[] s = { my_map.x, my_map.y };
>     //    q.Enqueue(s);
>     //    used[s[0], s[1]] = true;
>     //    int[] null_ = { -1, -1 };
>     //    p[s[0], s[1]] = null_;
>     //    while (q.Count > 0 && notExpl_size < 1) {
>     //        int[] v = q.Dequeue(); int z = v[0], t = v[1];
>     //        for (int i = 0; i < 4 && notExpl_size < 1; ++i) {
>     //            int dx = 0, dy = 0; if (i == 0) dx = -1; if (i == 1) dy = -1; if (i == 2) dx = 1; if (i == 3) dy = 1;
>     //            bool Can = this.Can(z, t, i) == 1;
>     //            int[] to = { z + dx, t + dy };
>     //            if (Can && !used[to[0], to[1]]) {
>     //                used[to[0], to[1]] = true;
>     //                q.Enqueue(to);
>     //                p[to[0], to[1]] = v;
>     //                if (indspy[to[0], to[1]] > 0 && notExpl_size < 1)
>     //                    if (Check.treasures(indspy[to[0], to[1]] - 1) > 0)
>     //                        notExpl[++notExpl_size] = to;
>     //            }
>     //        }
>     //    }
>     //}
>     public struct point {
>         public int x, y;
>         public point(int X, int Y) { x = X; y = Y; }
>         public static bool operator ==(point p1, point p2) => p1.x == p2.x && p1.y == p2.y;
>         public static bool operator !=(point p1, point p2) => (p1.x != p2.x || p1.y != p2.y);
>         public static implicit operator point(Coord cor) => new point(cor.x, cor.y);
>     }
>     protected void InitBFS() {
> 
>     }
>     protected static class Statement {
>         public static bool BFS(int stat) {
>             return true;
>         }
>     }
>     protected static class Change {
>         public static void BFS(int stat) {
> 
>         }
>     }
>     protected void BFS(point a, int stat = 0) {
>         InitBFS();
>         Queue<point> q = new Queue<point>();
>         q.Enqueue(a);
>         while (q.Count > 0 && Statement.BFS(stat)) {
> 
>         }
>     }
> }